//
//  AnyCodableTests.swift
//  tealium-swift
//
//  Created by Enrico Zannini on 18/08/21.
//  Copyright Â© 2021 Tealium, Inc. All rights reserved.
//

import XCTest
@testable import TealiumCore

/// Use this specific date to avoid losing Double precision when comparing a Date() with one generated by a ISO8601 string
let specificDate = Date(timeIntervalSinceReferenceDate: 0)

class AnyCodableTests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }
    
    func testNilAnyCodable() {
        let codable = AnyCodable(nil)
        XCTAssertTrue(codable.value is Void)
    }

    func testBool() throws {
        try encodeTest(value: true)
        try encodeTest(value: false)
    }
    
    func testString() throws {
        try encodeTest(value: "text")
        try encodeTest(value: "")
    }
    
    func testInt() throws {
        try encodeTest(value: 0)
        try encodeTest(value: 12)
        try encodeTest(value: -1)
        try encodeTest(value: Int32(20))
        try encodeTest(value: Int64(2))
        try encodeTest(value: Int.max)
        try encodeTest(value: Int.min)
    }
    
    func testDouble() throws {
        try encodeTest(value: Double.zero)
        try encodeTest(value: Double(3.4))
        try encodeTest(value: Double(-23.5))
        try encodeTest(value: Double.infinity)
        try encodeTest(value: Double.greatestFiniteMagnitude)
    }
    
    func testDoubleNan() throws {
        let nanData = try encode(Double.nan)
        let nanRes: Double = try decode(nanData)
        XCTAssertTrue(nanRes.isNaN)
    }
    
    func testFloat() throws {
        try encodeTest(value: Float.zero)
        try encodeTest(value: Float(3.4))
        try encodeTest(value: Float(-23.5))
        try encodeTest(value: Float.infinity)
        try encodeTest(value: Float.greatestFiniteMagnitude)
    }
    
    func testFloatNan() throws {
        let nanData = try encode(Float.nan)
        let nanRes: Float = try decode(nanData)
        XCTAssertTrue(nanRes.isNaN)
    }
    
    func testNSNumber() throws {
        try nsNumberTest(value: true)
        try nsNumberTest(value: false)
        try nsNumberTest(value: 4)
        try nsNumberTest(value: Double(2.2))
        try nsNumberTest(value: Float(4.5))
        try nsNumberTest(value: Double.greatestFiniteMagnitude)
        try nsNumberTest(value: Double.infinity)
        try nsNumberTest(value: Float.greatestFiniteMagnitude)
        try nsNumberTest(value: Float.infinity)
        try nsNumberTest(value: UInt(32))
        try nsNumberTest(value: UInt32(2))
        try nsNumberTest(value: Int8(3))
        try nsNumberTest(value: UInt16(17))
        try nsNumberTest(value: Int16(6))
    }
    
    func testNSString() throws {
        try nsStringTest(value: "text")
        try nsStringTest(value: "")
        try encodeAnyCodableTest(AnyCodable(NSString("some")))
        try encodeAnyCodableTest(AnyCodable(NSString("")))
    }
    
    func testNSDate() throws {
        try nsDateTest(value: specificDate)
    }
    
    func testDate() throws {
        try encodeTest(value: specificDate)
    }
    
    func testArray() throws {
        try encodeTest(value: [Int]())
        try encodeTest(value: [1,2,3])
        try encodeTest(value: ["1","2","3"])
        try encodeTest(value: [specificDate])
    }
    
    func testAnyArray() throws {
        let anyArray: [Any] = [1, "2", Double.infinity, specificDate]
        let data = try encode(anyArray)
        let codable: AnyCodable = try decode(data)
        let resArray = codable.value as! [Any]
        XCTAssertEqual(anyArray[0] as! Int, resArray[0] as! Int)
        XCTAssertEqual(anyArray[1] as! String, resArray[1] as! String)
        XCTAssertEqual(anyArray[2] as! Double, resArray[2] as! Double)
        XCTAssertEqual(specificDate.iso8601String, resArray[3] as! String) // Dates are converted to strings for generic Any type
    }
    
    func testNSNumberArray() throws {
        let numbers = [NSNumber(1), NSNumber(value: Double(0.4))]
        let data = try encode(numbers)
        let codable: AnyCodable = try decode(data)
        XCTAssertEqual(numbers, codable.value as! [NSNumber])
    }
    
    func testNSStringArray() throws {
        let numbers = [NSString("1"), NSString("")]
        let data = try encode(numbers)
        let codable: AnyCodable = try decode(data)
        XCTAssertEqual(numbers, codable.value as! [NSString])
    }
    
    func testNonCodableArray() throws {
        let nulls = [NSNull(), NSNull(), NSNull()]
        let data = try encode(nulls)
        let codable: AnyCodable = try decode(data)
        XCTAssertEqual(nulls, codable.value as! [NSNull])
    }
    
    func testDictionary() throws {
        try encodeTest(value: [String:Int]())
        try encodeTest(value: ["1":1,"2":2,"3":3])
        try encodeTest(value: ["1":"1","2":"2","3":"3"])
        try encodeTest(value: ["d": specificDate])
    }
    
    func testAnyDictionary() throws {
        let anyArray: [String:Any] = ["1":1, "2":"2", "3":Double.infinity, "4": specificDate]
        let data = try encode(anyArray)
        let codable: AnyCodable = try decode(data)
        let resDict = codable.value as! [String:Any]
        XCTAssertEqual(anyArray["1"] as! Int, resDict["1"] as! Int)
        XCTAssertEqual(anyArray["2"] as! String, resDict["2"] as! String)
        XCTAssertEqual(anyArray["3"] as! Double, resDict["3"] as! Double)
        XCTAssertEqual(specificDate.iso8601String, resDict["4"] as! String) // Dates are converted to strings for generic Any type
    }
    
    func testNSNumberDictionary() throws {
        let numbers = ["1": NSNumber(1), "2": NSNumber(value: Double(0.4))]
        let data = try encode(numbers)
        let codable: AnyCodable = try decode(data)
        XCTAssertEqual(numbers, codable.value as! [String:NSNumber])
    }
    
    func testNonCodableDictionary() throws {
        let nulls = ["1":NSNull(), "2":NSNull(), "3":NSNull()]
        let data = try encode(nulls)
        let codable: AnyCodable = try decode(data)
        XCTAssertEqual(nulls, codable.value as! [String:NSNull])
    }
    
    func testNil() throws {
        let codable = AnyCodable(nil)
        try encodeAnyCodableTest(codable)
    }
    
    func testVoid() throws {
        let codable = AnyCodable(())
        try encodeAnyCodableTest(codable)
    }
    
    func testNSNull() throws {
        let codable = AnyCodable(NSNull())
        try encodeAnyCodableTest(codable)
    }
    
    func testCodableObject() throws {
        let date = specificDate
        let num = Double(23142323.12314)
        let obj = CodableObject(s: "someValueWithAVeryLongString", d: date, n: num)
        try encodeTest(value: obj)
    }
    
    func testCodableObjectToDict() throws {
        let date = specificDate
        let inf = Double.infinity
        let num = Double(23142323.12314)
        let obj = CodableObject(s: "someValue", d: date, n: inf)
        let obj2 = CodableObject(s: "someValueWithAVeryLongString", d: date, n: .nan)
        let obj3 = CodableObject(s: "someValueWithAVeryLongString", d: date, n: num)
        let dict = obj.encoded!
        let dict2 = obj2.encoded!
        let dict3 = obj3.encoded!
        XCTAssertEqual(String(describing: type(of: dict["someString"]!)), "NSTaggedPointerString")
        XCTAssertEqual(String(describing: type(of: dict2["someString"]!)), "__NSCFString")
        XCTAssertEqual(String(describing: type(of: dict["someNumber"]!)), "NSTaggedPointerString")
        XCTAssertEqual(String(describing: type(of: dict2["someNumber"]!)), "NSTaggedPointerString")
        XCTAssertEqual(String(describing: type(of: dict3["someNumber"]!)), "__NSCFNumber")
        
        let data = try encodeAnyCodable(AnyCodable(dict))
        let res: [String: AnyCodable] = try decode(data)
        XCTAssertEqual(String(describing: type(of: res["someString"]!.value)), String(describing: String.self))
        XCTAssertEqual(res["someNumber"]!.value as? Double, inf)
        XCTAssertEqual(date.iso8601String, res["someDate"]?.value as! String) // Dates are converted to strings for generic Any type
        
        let data2 = try encodeAnyCodable(AnyCodable(dict2))
        let res2: [String: AnyCodable] = try decode(data2)
        XCTAssertEqual(String(describing: type(of: res2["someString"]!.value)), String(describing: String.self))
        XCTAssertTrue((res2["someNumber"]!.value as? Double)!.isNaN)
        XCTAssertEqual(date.iso8601String, res2["someDate"]?.value as! String) // Dates are converted to strings for generic Any type
        
        let data3 = try encodeAnyCodable(AnyCodable(dict3))
        let res3: [String: AnyCodable] = try decode(data3)
        XCTAssertEqual(String(describing: type(of: res3["someString"]!.value)), String(describing: String.self))
        XCTAssertEqual(res3["someNumber"]!.value as? Double, num)
        XCTAssertEqual(date.iso8601String, res3["someDate"]?.value as! String) // Dates are converted to strings for generic Any type
    }
    
    private func nsNumberTest<T: Decodable & Equatable>(value: T) throws {
        guard let number = value as? NSNumber else {
            throw NSError(domain: "Invalid Argument", code: 1, userInfo: nil)
        }
        let data = try encode(number)
        let res: T = try decode(data)
        XCTAssertEqual(value, res)
    }
    
    private func nsStringTest<T: Decodable & Equatable>(value: T) throws {
        guard let string = value as? NSString else {
            throw NSError(domain: "Invalid Argument", code: 1, userInfo: nil)
        }
        let data = try encode(string)
        let res: T = try decode(data)
        XCTAssertEqual(value, res)
    }
    
    private func nsDateTest<T: Decodable & Equatable>(value: T) throws {
        guard let nsDate = value as? NSDate else {
            throw NSError(domain: "Invalid Argument", code: 1, userInfo: nil)
        }
        let data = try encode(nsDate)
        let res: T = try decode(data)
        XCTAssertEqual(nsDate, res as Any as? NSDate)
    }
    
    private func encodeTest<T: Decodable & Equatable>(value: T) throws {
        let data = try encode(value)
        let res: T = try decode(data)
        XCTAssertEqual(value, res)
    }
    
    private func encodeAnyCodableTest(_ codable: AnyCodable) throws {
        let data = try encodeAnyCodable(codable)
        let anyCodableRes = try decodeAnyCodable(data)
        XCTAssertEqual(codable, anyCodableRes)
    }
    
    private func encode(_ value: Any) throws -> Data {
        return try encodeAnyCodable(AnyCodable(value))
    }
    
    private func decode<T: Decodable>(_ data: Data) throws -> T {
        return try Tealium.jsonDecoder.decode(T.self, from: data)
    }
    
    private func encodeAnyCodable(_ codable: AnyCodable) throws -> Data {
        return try Tealium.jsonEncoder.encode(codable)
    }
    
    private func decodeAnyCodable(_ data: Data) throws -> AnyCodable {
        return try Tealium.jsonDecoder.decode(AnyCodable.self, from: data)
    }

}

class CodableObject: Codable, Equatable {
    static func == (lhs: CodableObject, rhs: CodableObject) -> Bool {
        return (lhs.someNumber == rhs.someNumber || lhs.someNumber.isNaN && rhs.someNumber.isNaN)
            && lhs.someString == rhs.someString
            && lhs.someDate == rhs.someDate
    }
    
    let someString: String
    let someDate: Date
    let someNumber: Double
    init(s: String, d: Date, n: Double) {
        someString = s
        someDate = d
        someNumber = n
    }
    enum CodingKeys: String, CodingKey {
        case someString
        case someDate
        case someNumber
    }
}
